---
title: "WMR 2016 Access to care"
author: "jp"
date: "9/22/2016"
output: 
  html_document: 
    toc: yes
---

```{r, include= FALSE}

library(knitr)
library(scales, quietly = TRUE)
library(data.table)
library(dtplyr)
library(tidyverse, quietly = TRUE)
library(countrycode)
library(survey)

opts_chunk$set( echo = TRUE, cache = TRUE )


```

All available surveys from Sub-Saharan Africa from 2000 to present were downloaded from DHS.  

```{r}

source("file_list.r")

subsahara = countrycode_data %>%
  filter( region %in% c("Middle Africa", "Western Africa", "Eastern Africa", "Southern Africa")) %>% 
  select( country.name, iso3c ) 


files = files %>% 
  mutate( country.name = countrycode(country, "country.name", "country.name")) %>%
  filter( survey!="", year >= 2000 , country.name %in% subsahara$country.name)

# not_needed = c('Bangladesh', 'Pakistan', 'Philippines', 'Comoros')

survey_list = files %>% count(country, survey, year) %>% select(-n)

nsurveys = nrow(survey_list)
ncountries = length( unique( files$country ) )

```

# `r nsurveys` surveys since 2000 from `r ncountries` countries (as of winter 2016)

# Select variables of interest  for access to care 

```{r}

dd <-readRDS("dictionary.rds")  # about 6 sec

source('dhs_variable_selection.R')

# list variables and variable names
# lv = dd %>% mutate( item_name = tolower(Item_Name) ) %>% 
#   filter( item_name %in% some_variables() ) %>% # comment this line out to get full list of variables
#   filter( !grepl( "NA", Item_Label, fixed = TRUE) ) %>%
#   group_by( item_name ) %>%
#   count( Item_Label ) %>%
#   arrange( -n ) %>%
#   summarise( item_label = first( Item_Label ) ) %>% 
#     arrange( item_name )

# View(lv)

# select variables for this analysis, v
v =  c('v000', 
       'v001', 'v002', 'v003', 'v005', 'v021', 'v023', 'v024', 'v025', 
       'weight.c', 'weight.hm', 'weight.w', 'weight.h', 
       'hv001',  'hv002', 'hv003',  'hv005', 'hv007', 'hv021', 'hv023', 'hv024', 'hv025',
       'hvidx', 'b16',
       'h22', 'hv105', 'h47', 
       'hml16', # age in years
       'hml32', 'hml35',
      'h32a', 'h32b', 'h32c', 'h32d', 'h32e', 'h32f', 'h32g', 'h32h', 'h32i', 'h32s', #public/govt
      'h32j', 'h32k', 'h32l', 'h32m', 'h32n', 'h32o', 'h32p', 'h32q', 'h32r', #private
      'h32t', 'h32u', 'h32v', 'h32w', 'h32x', # informal privage/other
      'h32y', # no medical rx
      'h32z' # medical rx.  what's that mean?
      )

lv = dd %>% mutate( item_name = tolower(Item_Name) ) %>% 
  filter( item_name %in% v ) %>% # comment this line out to get full list of variables
  filter( !grepl( "NA", Item_Label, fixed = TRUE) ) %>%
  group_by( item_name ) %>%
  count( Item_Label ) %>%
  arrange( -n ) %>%
  summarise( item_label = first( Item_Label ) ) %>% 
  arrange( item_name )

kable(lv, row.names = FALSE)
```



# create dataset. run one time after updating or adding surveys

```{r, eval=FALSE}
source("dhs_load_survey.R")

nsurveys = nrow(survey_list)
index = row.names(survey_list)
p <- progress_estimated(nsurveys)

x <- vector("list", length( nsurveys)) 

translate = FALSE  # optional translation of values to label.  
  # NB: Does not work well for all variables

for (i in seq_along( index ) ){
  
   p$pause(0.1)$tick()$print()
  
  .country = survey_list[i, ]$country
  .iso3c = countrycode( survey_list[i, ]$country, "country.name", "iso3c")
  .survey = survey_list[i, ]$survey
  .year = survey_list[i, ]$year
  .survey_year = paste(.survey, .year)

  print( paste(.country, .survey, .year))
  
  svy <- try( silent = TRUE,
    load_survey_object( printout = FALSE, 
                            vars = v, 
                            .country = .country, 
                            .survey_year = .survey_year)
  )

  if ( class(svy) == "try-error" ){ next()}

  # returns: svy.h, svy.c, svy.w, svy.hm, vars_x, x
  # svy.h <- svy[[1]]
  # svy.c <- svy[[2]]
  # svy.w <- svy[[3]]
  # svy.hm <- svy[[4]]
  has_vars = svy[[5]]
  x[[i]] = svy[[6]] 
  
  x[[i]]$country = rep( .country, nrow(x[[i]]) )
  x[[i]]$iso3c = rep( .iso3c, nrow(x[[i]]) )
  x[[i]]$year = rep( .year, nrow(x[[i]]) )
  x[[i]]$survey = rep( .survey, nrow(x[[i]]) )

  # TODO: optional- relate dictionary to survey 

  # refine dictionary for this country-survey 
  dict = dd %>% filter_( ~country == .country , ~survey == .survey, ~year == .year,
                        ~Item_Name %in% toupper(names(has_vars))
                        )

  # # TODO: only for columns with >4 values (others easier to keep as numeric)
  # # Deriving this table should happen once, before loop
  # v = dd %>% filter( tolower(Item_Name) %in% variables) %>% group_by( Item_Name, label ) %>% 
  #   summarise( n = n()) %>% group_by( Item_Name) %>% count(Item_Name) %>% filter(nn>4) 

  if (translate){
  y = x[[i]]
  
    for (col in 1:length(colnames(y))){
      column = tolower( colnames(y)[col] )
      
      dict_var = dict %>% 
        mutate( item_name = tolower(Item_Name)) %>%
        filter_( ~item_name == column ) %>% # , ~file == "Household Member Recode"
        count( value, label) %>% select(-n)
      
      old_value = y[, col]
      new_value = dict_var[ match( old_value, dict_var$value ), ]$label
      y[, col] = ifelse( is.na( new_value), old_value, new_value)
    }
      x[[i]] = y
}

  # if (is.null(X) ){ X <- x; next()}
  # X = rbindlist( list(X, x), use.names = TRUE, fill = TRUE)
  
}
  
# X = dplyr:: bind_rows( x )  # will throw error is column types dont match 
X = rbindlist(x, fill = TRUE) %>% rownames_to_column("id")


# X = as_tibble(X)

saveRDS(X, "X.rds")

nvars = ncol(X)
rows = nrow(X)

object.size(X)
```

# create sqlite db from X.rds: run one time after updating or adding surveys

```{r, eval= FALSE}

library(DBI)
# devtools::install_github("rstudio/pool")
library(pool)


X = readRDS( "X.rds")
X_db <- src_sqlite("X.sqlite3", create = T)
Xsql <- copy_to(X_db, X, temporary = FALSE, indexes = list(c("country", "year", "survey"), "hv023"))

```


# Load last dataset created

```{r}


library(DBI)
# devtools::install_github("rstudio/pool")
library(pool)

pool <- dbPool(
  drv = "SQLite",
  dbname = "X.sqlite3"
)

namesX = dbListFields(pool, "X")
provider_cols <- which( grepl("h32", namesX ) )

dbListTables(pool)
dbListFields(pool, "X")
# dbGetQuery(pool, "SELECT * from X LIMIT 5;")  # these two lines do same thing
src_pool(pool) %>% tbl("X") %>% head()


```

# inspect data for unwanted values (e.g. 9 for missing)

```{r}

# TODO: this is slow; try to do with data.table
# inspect  = lapply( namesX[provider_cols],  function(x) X %>% count_(x) )
# 
# for (i in  seq_along(provider_cols) ){
#   
#   print( inspect[i] )
# }       

```


# define provider types

```{r}

# 'h32a', 'h32b', 'h32c', 'h32d', 'h32e', 'h32f', 'h32g', 'h32h', 'h32i', 'h32s', #public/govt
# 'h32j', 'h32k', 'h32l', 'h32m', 'h32n', 'h32o', 'h32p', 'h32q', 'h32r', #private
# 'h32t', 'h32u', 'h32v', 'h32w', 'h32x', # informal privage/other
# 'h32y', # no medical rx
# 'h32z' # medical rx.  what's that mean?

provider_public <- which( namesX %in%  c('h32a', 'h32b', 'h32c', 'h32d', 'h32e', 'h32f', 'h32g', 'h32h', 'h32i', 'h32s') )

provider_private <- which( namesX %in%  c('h32j', 'h32k', 'h32l', 'h32m', 'h32n', 'h32o', 'h32p', 'h32q', 'h32r') )

provider_other <- which( namesX %in%  c('h32t', 'h32u', 'h32v', 'h32w', 'h32x') )

provider_none <- which( namesX %in%  c('h32y') )

provider_any <- which( namesX %in%  c('h32z') )

is1 = function(x) x %in% 1
is01 = function(x) x %in% 0:1

```

```{r, eval=FALSE}

# in memory version with data.table
Sys.time()

X = X[ , provider_public1 := rowSums( sapply(.SD, is1) ) >0, .SDcols = colnames(X)[provider_public] ]
X = X[ , provider_public01 := rowSums( sapply(.SD, is01) ) >0, .SDcols = colnames(X)[provider_public] ]
X = X[ , provider_public := ifelse( provider_public1 == TRUE, TRUE ,
                                    ifelse( provider_public01 == TRUE, FALSE, NA)) ]

X = X[ , provider_private1 := rowSums( sapply(.SD, is1)  )>0, .SDcols = colnames(X)[provider_private] ]
X = X[ , provider_private01 := rowSums( sapply(.SD, is01)  )>0, .SDcols = colnames(X)[provider_private] ]
X = X[ , provider_private := ifelse( provider_private1 == TRUE, TRUE ,
                                    ifelse( provider_private01 == TRUE, FALSE, NA)) ]

X = X[ , provider_other1 := rowSums( sapply(.SD, is1)  )>0, .SDcols = colnames(X)[provider_other] ]
X = X[ , provider_other01 := rowSums( sapply(.SD, is01)  )>0, .SDcols = colnames(X)[provider_other] ]
X = X[ , provider_other := ifelse( provider_other1 == TRUE, TRUE ,
                                    ifelse( provider_other01 == TRUE, FALSE, NA)) ]

Sys.time() # approx 1 hr.  Ouch! without sapply, a couple of minutes. 


X = X[ , provider_none := h32y ]
X = X[ , provider := h32z ]

```


```{r}

library(DBI)
# devtools::install_github("rstudio/pool")
library(pool)

pool <- dbPool(
  drv = "SQLite",
  dbname = "X.sqlite3"
)

namesX = dbListFields(pool, "X")
providers <- which( grepl("h32", namesX ) )

# db version with dplyr
Xdb = tbl( src_pool(pool), "X")

# provider rates ####

provider_rate = function(
  provider = "Other",
  provider_cols = provider_other,
  db = Xdb
  ){
  
  cols = c("country", "survey", "year",
           "hv023" , # strata
           "weight.hm", namesX[provider_cols])
  
  xx = db %>% 
    select_( .dots = cols  ) %>% collect(n=Inf) %>% 
    mutate( id = seq_along( country) ) 
  
  xxl = xx %>%
    gather(var, val, -id, -country, -survey, -year, -hv023, -weight.hm) %>%
    data.table()
  
  xx. = xxl[, .(
    Y = sum( val, na.rm = TRUE) > 0,
    YN = sum( !is.na( val) ) > 0 
    ),  by = list(country, survey, year, hv023, id) ]
  
  xx. = xx.[ data.table(xx)[, .(id, weight.hm)], on = "id"]
  
  xx.. = xx.[, .(
    provider = provider, 
    # weight reusults of individuals within strata
    Y = sum( as.numeric(Y * weight.hm), na.rm = TRUE),
    YN = sum(as.numeric(YN * weight.hm), na.rm = TRUE),
    
    # This weight need to weight strata within countries
    weight = sum( as.numeric(weight.hm), na.rm = TRUE) 
    ),
    by = list(country, survey, year, hv023) ]
  
  return(xx..)

}

other = provider_rate("other", provider_other )
private = provider_rate("private", provider_private )
public = provider_rate("public", provider_public )
none =  provider_rate("none", provider_none )
  
Xdb %>% summarize(n())
nrow(public); nrow(private); nrow(other)

poolClose(pool)


# Join  ####

provider = bind_rows( public ,private, other, none)

provider[, percent := Y/YN ]

provider[, yr := as.integer(substr(year, 1, 4))]

provider[, iso2c := countrycode(country, "country.name", "iso2c")]

# Add population < 5  for re-weighting ####
pop05 = readRDS( "../Populations/pop05_africa.RDS")
str(pop05)

# join pop estimates
provider = data.table(
  inner_join( as.data.frame(provider),  pop05[, c("iso2c", "year", "pop")],
                   by = c("yr" = "year", "iso2c" = "iso2c"))
)

# #check totals...there is some issue where thery dont add to 1
# providerSummary = provider[, .(mean = mean(percent, na.rm = TRUE)), by =
#                              list(country, survey, year, provider) 
#                            ] %>%
#   spread(provider, mean) %>%
#   mutate( total = public+private+other+none)
# 
# View(providerSummary)

```


```{r, eval=FALSE}
# dplyr crosstabs
X %>% group_by(provider, provider_none) %>% tally() %>% spread(provider_none, n)
X %>% group_by(provider, provider_public) %>% tally() %>% spread(provider_public, n)
X %>% group_by(provider, provider_private) %>% tally() %>% spread(provider_private, n)
X %>% group_by(provider_public1, provider_public01) %>% tally() %>% spread(provider_public01, n)

# ages
X %>% group_by(hml16, provider_public) %>% tally() %>% spread(provider_public, n) %>%
  mutate(percent_public = `TRUE` / (`TRUE` + `FALSE`) )
```


# Visualize raw data

```{r}

d = provider %>% 
  mutate( yr = as.integer( substr(year, 0 , 4)) ,
          
          # if more than 1 year in survey, use 2nd
          yr = ifelse( nchar(year)>4, yr + 1, yr)
          )  

# group by country
d =  d %>% group_by(country, survey, yr, provider) %>%
  filter( YN > 0 ) %>%
  summarise( 
    percent =   sum(Y * weight)  / sum(YN * weight ),
    pop = first(pop) 
  )

# unweighted 
ggplot( d, aes( yr, percent, color = provider, group = provider)) + 
  guides(color = guide_legend(reverse = TRUE)) +
  geom_point() +
  geom_smooth( )

# weighted 
ggplot( d, aes( yr, percent, color = provider, group = provider)) + 
  guides(color = guide_legend(reverse = TRUE)) +
  geom_point() +
  geom_smooth( aes(weight = pop) )

```

```{r, cache=FALSE}
library(ggvis)

d = provider %>% 
  mutate( yr = as.integer( substr(year, 0 , 4))) 

# group by country
d =  d %>% group_by(country, survey, yr, provider) %>%
  filter( YN > 0 ) %>%
  summarise( 
    percent =   sum(Y * weight)  / sum(YN * weight ),
    pop = first(pop) 
  )

d$id <- 1:nrow(d)

tooltip = function(data){
  if(is.null(data)) return(NULL)
  row <- d[d$id == data$id, ]
  # paste0(names(row), ": ", format(row), collapse = "<br />")
  paste( row$country, row$survey, row$year, row$yr, row$n )
}

d %>% 
  filter( complete.cases(.)) %>%
  ggvis(~yr, ~percent, stroke = ~provider, fill = ~provider)  %>% 
  layer_points( key := ~id ) %>%
  # group_by( provider ) %>%
  # layer_smooths( ) %>%
  add_tooltip( tooltip, "hover" )

```


# classical model

```{r, eval=FALSE}

dm = provider %>%
  select( -public, -private, -other) %>%
  mutate( yr = as.integer( substr(year, 0 , 4))) %>% 
  select( - year ) %>%
  gather(provider, val, -country, -survey, -yr) 

m = glm( val ~ country + provider + yr,  data = dm)



```

# bayes model
```{r, eval=FALSE}
library(rethinking)

d$country_id = coerce_index( d$country)
d$provider_id = coerce_index( d$provider)

d. = d %>% select(country_id, val, yr) %>%
  filter(complete.cases(.)) %>% as.data.frame()

    m1 = map2stan(
        alist(
          val ~ dbinom( 1, p ),
          logit(p) <- a_country[country_id]  + b*yr,
          a_country[country_id] ~ dnorm( ac, sigma_c),
          ac ~ dnorm( 0, 2),
          b ~ dnorm(0, 2),
          sigma_c ~ dcauchy(0, 2),
          sigma_p ~ dcauchy(0, 2)
          
        ), data =  d., warmup = 500, iter = 4500, chains = 1)
    
    # same by map
    ## crude
    mm = map(
        alist(
          hml32 ~ dbinom( 1, p ),
          logit(p) <- a ,
          a ~ dnorm( 0, 10)
        ), data =  d)
    
    mmp = precis(mm) 
    unlist( logistic( mmp@output ) )
```

